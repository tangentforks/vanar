/*****************************************************************************
  PROJECT:     NAVM AOT COMPILER
  DESCRIPTION: COMPILER FOR THE NAVM LEVEL 1 ISA AS IL REPRESENTATION
  INFO:        ABSTRACT FRONTEND INTERFACE OF THE COMPILER
  AUTHOR:      MATTHIAS SCHIRM
  COPYRIGHT:   (C) 2013 MATTHIAS SCHIRM, ALL RIGHTS RESERVED
  LICENCE:     BSD STYLE, SEE LICENCE.TXT
  COMPILER:    GCC V4 ENGINE
  STANDARD:    ANSI C 1989 + POSIX 1
  HISTORY:     7-15-2013: FIRST VERSION
  TO-DO:       NONE AT CURRENT
  ****************************************************************************/
  
/* -------------------------------------------------------------------------
   INFO: Help routines, macros and declarations.
   ------------------------------------------------------------------------- */

#define notMacroOpcode                                                        \
(ins.aOpcodes[i] != 76)  && (ins.aOpcodes[i] != 102) &&                       \
(ins.aOpcodes[i] != 119) && (ins.aOpcodes[i] != 136) &&                       \
(ins.aOpcodes[i] != 140) && (ins.aOpcodes[i] != 153) &&                       \
(ins.aOpcodes[i] != 156) && (ins.aOpcodes[i] != 170) &&                       \
(ins.aOpcodes[i] != 172) && (ins.aOpcodes[i] != 187) &&                       \
(ins.aOpcodes[i] != 208) && (ins.aOpcodes[i] != 209) &&                       \
(ins.aOpcodes[i] != 211) && (ins.aOpcodes[i] != 212) &&                       \
(ins.aOpcodes[i] != 213) && (ins.aOpcodes[i] != 214) &&                       \
(ins.aOpcodes[i] != 215) && (ins.aOpcodes[i] != 216) &&                       \
(ins.aOpcodes[i] != 217) && (ins.aOpcodes[i] != 218) &&                       \
(ins.aOpcodes[i] != 220) && (ins.aOpcodes[i] != 223) &&                       \
(ins.aOpcodes[i] != 236) && (ins.aOpcodes[i] != 238) &&                       \
(ins.aOpcodes[i] != 255)

enum {insLI,  insLD,  insST, insADD, insDIV, insMUL, insAND, insGOR, insXOR,
      insSHL, insSHR, insCP, insDUP, insDRP, insSWP, insROT};

enum {opcLI  = 76,  opcST  = 102, opcDUP = 119, opcDRP = 136, opcB   = 140,
      opcSWP = 153, opcBC  = 156, opcROT = 170, opcBS  = 172, opcLD  = 187,
      opcBCS = 208, opcBR  = 209, opcBCR = 211,	opcR   = 212, opcRC  = 213,
      opcADD = 214, opcDIV = 215, opcMUL = 216,	opcAND = 217, opcGOR = 218,	
      opcCP  = 220, opcXOR = 223, opcSHL = 236, opcSYS = 238, opcSHR = 255};
      
bool immRange (sWord pImm, uByte bitSize)
  {sWord test = pImm >> (bitSize-1);
   if (test != 0) return false; else return true;}

/* -------------------------------------------------------------------------
   INFO: Compiler functions for single instructions, extending there
   backend equivalents (basical adding state-dependent functionality common
   to all frontend compilation-strategies)
   ------------------------------------------------------------------------- */

pWord pImm;

void navmFrontendCompLI (pNavmBackend p)
  {if (p->vLI < 8) p->vLI++; navmBackendCompLI (p, *pImm++);}

void navmFrontendCompLD (pNavmBackend p) {navmBackendCompLD (p);}
void navmFrontendCompST (pNavmBackend p) {navmBackendCompST (p);}

void navmFrontendCompADD (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompADD (p);}
      else {if (immRange (cfNavmBackendImmAddLen, *pImm) != false)
                 navmBackendCompAddImm (p, *pImm++);
            else navmBackendCompADD (p);}}

void navmFrontendCompDIV (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompDIV (p);}
      else {if (immRange (cfNavmBackendImmDivLen, *pImm) != false)
                 navmBackendCompDivImm (p, *pImm++);
            else navmBackendCompDIV (p);}}

void navmFrontendCompMUL (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompMUL (p);}
      else {if (immRange (cfNavmBackendImmMulLen, *pImm) != false)
                 navmBackendCompMulImm (p, *pImm++);
            else navmBackendCompMUL (p);}}

void navmFrontendCompAND (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompAND (p);}
      else {if (immRange (cfNavmBackendImmAndLen, *pImm) != false)
                 navmBackendCompAndImm (p, *pImm++);
            else navmBackendCompAND (p);}}
            
void navmFrontendCompGOR (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompGOR (p);}
      else {if (immRange (cfNavmBackendImmGorLen, *pImm) != false)
                 navmBackendCompGorImm (p, *pImm++);
            else navmBackendCompGOR (p);}}
            
void navmFrontendCompXOR (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompXOR (p);}
      else {if (immRange (cfNavmBackendImmXorLen, *pImm) != false)
                 navmBackendCompXorImm (p, *pImm++);
            else navmBackendCompXOR (p);}}

void navmFrontendCompSHL (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompSHL (p);}
      else {if (immRange (cfNavmBackendImmShlLen, *pImm) != false)
                 navmBackendCompShlImm (p, *pImm++);
            else navmBackendCompSHL (p);}}

void navmFrontendCompSHR (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompSHR (p);}
      else {if (immRange (cfNavmBackendImmShrLen, *pImm) != false)
                 navmBackendCompShrImm (p, *pImm++);
            else navmBackendCompSHR (p);}}

void navmFrontendCompCP (pNavmBackend p)
  {if (p->vLI > 0) {p->vLI--; navmBackendCompCP (p);}
      else {if (immRange (cfNavmBackendImmCpLen, *pImm) != false)
                 navmBackendCompCpImm (p, *pImm++);
            else navmBackendCompCP (p);}}

void navmFrontendCompDUP (pNavmBackend p) {navmBackendCompDUP (p);}
void navmFrontendCompDRP (pNavmBackend p) {navmBackendCompDRP (p);}
void navmFrontendCompSWP (pNavmBackend p) {navmBackendCompSWP (p);}
void navmFrontendCompROT (pNavmBackend p) {navmBackendCompROT (p);}

/* -------------------------------------------------------------------------
   INFO: The following compiler strategy fits for superscalar out-of-order
   designs with dynamic register sheduling (like all Intel and AMD cpu's
   since introduction of the Pentium line).
   ------------------------------------------------------------------------- */

void navmFrontendNsCiscPipe (pNavmBackend h, uOpcode ins)
  {uByte i1, i2, i;
   for (i = 0; i < 8; i++)
     {if (notMacroOpcode) 
         {i1 = ins.aOpcodes[i] & 0x0F; i2 = (ins.aOpcodes[i] >> 4) & 0x0F;
          switch (i1)
            {case insLI:  {navmFrontendCompLI  (h); break;}
             case insLD:  {navmFrontendCompLD  (h); break;}
             case insST:  {navmFrontendCompST  (h); break;}
             case insADD: {navmFrontendCompADD (h); break;}
             case insDIV: {navmFrontendCompDIV (h); break;}
             case insMUL: {navmFrontendCompMUL (h); break;}
             case insAND: {navmFrontendCompAND (h); break;}
             case insGOR: {navmFrontendCompGOR (h); break;}
             case insXOR: {navmFrontendCompXOR (h); break;}
             case insSHL: {navmFrontendCompSHL (h); break;}
             case insSHR: {navmFrontendCompSHR (h); break;}
             case insCP:  {navmFrontendCompCP  (h); break;}
             case insDUP: {navmFrontendCompDUP (h); break;}
             case insDRP: {navmFrontendCompDRP (h); break;}
             case insSWP: {navmFrontendCompSWP (h); break;}
             case insROT: {navmFrontendCompROT (h); break;}}
          switch (i2)
            {case insLI:  {navmFrontendCompLI  (h); break;}
             case insLD:  {navmFrontendCompLD  (h); break;}
             case insST:  {navmFrontendCompST  (h); break;}
             case insADD: {navmFrontendCompADD (h); break;}
             case insDIV: {navmFrontendCompDIV (h); break;}
             case insMUL: {navmFrontendCompMUL (h); break;}
             case insAND: {navmFrontendCompAND (h); break;}
             case insGOR: {navmFrontendCompGOR (h); break;}
             case insXOR: {navmFrontendCompXOR (h); break;}
             case insSHL: {navmFrontendCompSHL (h); break;}
             case insSHR: {navmFrontendCompSHR (h); break;}
             case insCP:  {navmFrontendCompCP  (h); break;}
             case insDUP: {navmFrontendCompDUP (h); break;}
             case insDRP: {navmFrontendCompDRP (h); break;}
             case insSWP: {navmFrontendCompSWP (h); break;}
             case insROT: {navmFrontendCompROT (h); break;}}}
      else {switch (ins.aOpcodes[i])
              {case opcLI:  {navmFrontendCompLI  (h); break;}
               case opcLD:  {navmFrontendCompLD  (h); break;}
               case opcST:  {navmFrontendCompST  (h); break;}
               case opcADD: {navmFrontendCompADD (h); break;}
               case opcDIV: {navmFrontendCompDIV (h); break;}
               case opcMUL: {navmFrontendCompMUL (h); break;}
               case opcAND: {navmFrontendCompAND (h); break;}
               case opcGOR: {navmFrontendCompGOR (h); break;}
               case opcXOR: {navmFrontendCompXOR (h); break;}
               case opcSHL: {navmFrontendCompSHL (h); break;}
               case opcSHR: {navmFrontendCompSHR (h); break;}
               case opcCP:  {navmFrontendCompCP  (h); break;}
               case opcDUP: {navmFrontendCompDUP (h); break;}
               case opcDRP: {navmFrontendCompDRP (h); break;}
               case opcSWP: {navmFrontendCompSWP (h); break;}
               case opcROT: {navmFrontendCompROT (h); break;}
               case opcBR:  goto endFunction;
               case opcBCR: goto endFunction;
               default:     errorHalt ("[navmFrontendNsCiscPipe]");}}}
      endFunction: i = i;}
